name: Deploy Medusa Backend (Terraform + Docker + ACR + App Service)

on:
  workflow_dispatch:
  push:
    branches:
      - main

env:
  IMAGE_NAME: medusa-backend

jobs:
  terraform:
    runs-on: ubuntu-latest
    outputs:
      acr_name: ${{ steps.outputs.outputs.acr_name }}
      acr_login_server: ${{ steps.outputs.outputs.acr_login_server }}
      app_service_name: ${{ steps.outputs.outputs.app_service_name }}
      resource_group_name: ${{ steps.outputs.outputs.resource_group_name }}
      db_host: ${{ steps.outputs.outputs.db_host }}
      db_port: ${{ steps.outputs.outputs.db_port }}
      db_name: ${{ steps.outputs.outputs.db_name }}
      db_user: ${{ steps.outputs.outputs.db_user }}
      db_password: ${{ steps.outputs.outputs.db_password }}
      cms_url: ${{ steps.outputs.outputs.cms_url }}

    steps:
      - name: Checkout infra repo (this repo)
        uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update -y && sudo apt-get install -y jq

      - name: Generate terraform.tfvars.json from clinic-config.json
        run: |
          # keep existing mapping (adjust clinic-config.json as needed for medusa)
          jq '{
            clinic_name: .clinic.name,
            clinic_environment: .clinic.environment,
            clinic_region: .clinic.region,
            strapi_repo: .strapi.repo,
            strapi_branch: .strapi.branch,
            strapi_admin_email: .strapi.admin_email,
            strapi_admin_password: .strapi.admin_password,
            db_name: .database.name,
            db_username: .database.username,
            db_password: .database.password,
            azure_resource_group_prefix: .azure.resource_group_prefix,
            azure_app_service_plan_sku: .azure.app_service_plan_sku,
            linked_storefront_url: .integration.linked_storefront_url,
            backend_url: .integration.backend_url,
            brand_primary_color: .clinic.branding.primary_color,
            brand_secondary_color: .clinic.branding.secondary_color,
            brand_logo_url: .clinic.branding.logo_url,
            brand_favicon_url: .clinic.branding.favicon_url,
            strapi_admin_firstname: .strapi.admin_firstname,
            strapi_admin_lastname: .strapi.admin_lastname
          }' clinic-config.json > terraform.tfvars.json
          echo "terraform.tfvars.json generated."

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Terraform Init
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
        run: terraform init

      - name: Terraform Apply (create infra)
        id: tf_apply
        env:
          ARM_CLIENT_ID: ${{ secrets.ARM_CLIENT_ID }}
          ARM_CLIENT_SECRET: ${{ secrets.ARM_CLIENT_SECRET }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.ARM_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.ARM_TENANT_ID }}
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          terraform apply -auto-approve -var-file="terraform.tfvars.json" -var="github_token=$GH_PAT"

      - name: Capture Terraform outputs
        id: outputs
        run: |
          echo "::debug::capturing terraform outputs"
          echo "acr_name=$(terraform output -raw acr_name)" >> $GITHUB_OUTPUT
          echo "acr_login_server=$(terraform output -raw acr_login_server)" >> $GITHUB_OUTPUT
          echo "app_service_name=$(terraform output -raw app_service_name)" >> $GITHUB_OUTPUT
          echo "resource_group_name=$(terraform output -raw resource_group_name)" >> $GITHUB_OUTPUT
          echo "db_host=$(terraform output -raw db_host)" >> $GITHUB_OUTPUT
          if terraform output -json db_port >/dev/null 2>&1; then
            echo "db_port=$(terraform output -raw db_port)" >> $GITHUB_OUTPUT
          else
            echo "db_port=5432" >> $GITHUB_OUTPUT
          fi
          echo "db_name=$(terraform output -raw db_name)" >> $GITHUB_OUTPUT
          echo "db_user=$(terraform output -raw db_user)" >> $GITHUB_OUTPUT
          echo "db_password=$(terraform output -raw db_password)" >> $GITHUB_OUTPUT
          if terraform output -json cms_url >/dev/null 2>&1; then
            echo "cms_url=$(terraform output -raw cms_url)" >> $GITHUB_OUTPUT
          else
            APP=$(terraform output -raw app_service_name)
            echo "cms_url=${APP}.azurewebsites.net" >> $GITHUB_OUTPUT
          fi

  deploy:
    needs: terraform
    runs-on: ubuntu-latest
    environment: production
    steps:

      - name: Checkout infra repo (this repo)
        uses: actions/checkout@v4

      - name: Show repo layout (debug)
        run: ls -la || true

      - name: Checkout Medusa backend repository
        uses: actions/checkout@v3
        with:
          repository: smarter-EMR/ecomm-terraform
          token: ${{ secrets.GH_PAT }}
          path: ecomm-terraform


      #since error persists, lets try and override config
      # - name: Override medusa-config.ts with JS version
      #   working-directory: ecomm-terraform/my-medusa-store
      #   run: |
      #     cat <<'EOF' > medusa-config.js
      #     import { loadEnv } from "@medusajs/framework/utils"

      #     // explicitly load environment variables
      #     loadEnv(process.env.NODE_ENV || "production", process.cwd())

      #     export default {
      #       projectConfig: {
      #         databaseUrl: process.env.DATABASE_URL,
      #         http: {
      #           storeCors: process.env.STORE_CORS || "*",
      #           adminCors: process.env.ADMIN_CORS || "*",
      #           authCors: process.env.AUTH_CORS || "*",
      #           jwtSecret: process.env.JWT_SECRET || "supersecret",
      #           cookieSecret: process.env.COOKIE_SECRET || "supersecret",
      #         },
      #       },
      #     }
      #     EOF

      #     echo "✔ medusa-config.js override created!"



      - name: Install Yarn
        run: npm install -g yarn


      #actual docker file, commenting this out to try dockerfile i have taken from medusa docs, used below.
      # - name: Create Dockerfile dynamically (inside my-medusa-store)
      #   working-directory: ecomm-terraform/my-medusa-store
      #   run: |
      #     cat <<'DOCKERFILE' > Dockerfile
      #     # ---------- BUILDER ----------
      #     FROM node:20 AS builder

      #     WORKDIR /server

      #     # Copy TS config first
      #     # COPY medusa-config.ts ./

      #     # Install dependencies
      #     COPY package.json package-lock.json ./
      #     #RUN yarn install --frozen-lockfile
      #     RUN npm install --legacy-peer-deps

      #     # Copy source
      #     COPY . .

      #     # Build project
      #     RUN yarn build

      #     # ---------- RUNTIME ----------
      #     FROM node:20 AS runtime

      #     WORKDIR /server

      #     # Install Medusa CLI
      #     RUN yarn global add @medusajs/cli

      #     # Copy entire project (IMPORTANT)
      #     COPY --from=builder /server /server
      #     #RUN cp medusa-config.ts /app/medusa-config.ts || true

      #     # Expose Medusa port
      #     EXPOSE 9000

      #     # Run migrations THEN start server
      #     CMD ["sh", "-c", "npx medusa db:migrate && medusa start"]
          
      #     DOCKERFILE
      #     echo "Dockerfile created in ecomm-terraform/my-medusa-store" 
      


      # #this is not the actual dockerfile i have created, i ijust took it from the medusa docs, it gives couldnt find index.html error, so doing the below dockerfile
      # - name: Create Dockerfile dynamically (inside my-medusa-store)
      #   working-directory: ecomm-terraform/my-medusa-store
      #   run: |
      #     cat <<'DOCKERFILE' > Dockerfile
      #     # Development Dockerfile for Medusa
      #     FROM node:20-alpine

      #     # Set working directory
      #     # WORKDIR /server

      #     # Copy package files and npm config
      #     COPY package.json package-lock.json ./

      #     # Install all dependencies using npm
      #     RUN npm install --legacy-peer-deps

      #     # Install Medusa CLI
      #     RUN npm install -g @medusajs/cli

      #     # Copy source code
      #     COPY . .

      #     #buid medusa
      #     RUN npm run build

      #     # Expose the port Medusa runs on
      #     EXPOSE 9000

      #     # Start with migrations and then the development server
      #     # CMD ["./start.sh"]
          
      #     CMD ["sh", "-c", "npx medusa db:migrate && npx medusa start"]

      #     DOCKERFILE
      #     echo "Dockerfile created in ecomm-terraform/my-medusa-store"



      # #using this dockerfile as initial step to resolve couldnt find index.html error
      # - name: Create Dockerfile dynamically (inside my-medusa-store)
      #   working-directory: ecomm-terraform/my-medusa-store
      #   run: |
      #     cat <<'DOCKERFILE' > Dockerfile
      #     # ---------- BUILDER ----------
      #     FROM node:20 AS builder

      #     WORKDIR /server

      #     COPY package.json package-lock.json ./
      #     RUN npm install --legacy-peer-deps

      #     COPY . .

      #     # Medusa build – this generates .medusa/server with admin
      #     RUN npm run build


      #     # ---------- RUNTIME ----------
      #     FROM node:20

      #     WORKDIR /server

      #     # install medusa cli
      #     RUN npm install -g @medusajs/cli

      #     COPY --from=builder /server /server

      #     EXPOSE 9000

      #     CMD ["sh", "-c", "npx medusa db:migrate && npx medusa start"]

      #     DOCKERFILE
      #     echo "Dockerfile created in ecomm-terraform/my-medusa-store"
      


      #trying to play around under .medusa/server to resolve the same error
      - name: Create Dockerfile dynamically (inside my-medusa-store)
        working-directory: ecomm-terraform/my-medusa-store
        run: |
          cat <<'DOCKERFILE' > Dockerfile
          FROM node:20-alpine

          # Set working directory
          WORKDIR /server

          # Copy package files
          COPY package.json package-lock.json ./

          # Install all dependencies
          RUN npm install --legacy-peer-deps

          # Copy source code
          COPY . .

          # Build Medusa to .medusa/server
          RUN npm run build

          # Move into the compiled directory
          WORKDIR /server/.medusa/server

          # Install production dependencies INSIDE the build folder
          RUN npm install --legacy-peer-deps

          #creating admin
          #RUN npx medusa user -e ali@clinic.com -p StrongPass123! || true

          EXPOSE 9000
          CMD ["sh", "-c", "npx medusa db:migrate && (npx medusa user -e ali@clinic.com -p StrongPass123! || true) && npx medusa start"]

          DOCKERFILE
          echo "Dockerfile created in ecomm-terraform/my-medusa-store"

      

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ACR Login
        run: |
          echo "ACR_NAME=${{ needs.terraform.outputs.acr_name }}"
          az acr login --name "${{ needs.terraform.outputs.acr_name }}"

      - name: Build Docker image
        working-directory: ecomm-terraform/my-medusa-store
        run: |
          SHORT_SHA=${GITHUB_SHA::7}
          ACR_SERVER="${{ needs.terraform.outputs.acr_login_server }}"
          IMAGE="${ACR_SERVER}/${{ env.IMAGE_NAME }}:${SHORT_SHA}"
          echo "Building image: $IMAGE"
          docker build -t "$IMAGE" .
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV

      - name: Push Docker image to ACR
        run: docker push "$IMAGE"

      - name: Get ACR credentials
        id: acrcreds
        run: |
          ACR_NAME="${{ needs.terraform.outputs.acr_name }}"
          USER=$(az acr credential show --name "$ACR_NAME" --query "username" -o tsv)
          PASS=$(az acr credential show --name "$ACR_NAME" --query "passwords[0].value" -o tsv)
          echo "ACR_USER=$USER" >> $GITHUB_ENV
          echo "ACR_PASS=$PASS" >> $GITHUB_ENV



      - name: Configure App Service container + app settings
        run: |
          RG="${{ needs.terraform.outputs.resource_group_name }}"
          APP="${{ needs.terraform.outputs.app_service_name }}"

          # Set container image
          az webapp config container set \
            --name "$APP" \
            --resource-group "$RG" \
            --container-image-name "$IMAGE" \
            --container-registry-url "https://${{ needs.terraform.outputs.acr_login_server }}" \
            --container-registry-user "$ACR_USER" \
            --container-registry-password "$ACR_PASS"

          # Build DB URL
          DB_HOST="${{ needs.terraform.outputs.db_host }}"
          DB_PORT="${{ needs.terraform.outputs.db_port }}"
          DB_NAME="${{ needs.terraform.outputs.db_name }}"
          DB_USER="${{ needs.terraform.outputs.db_user }}"
          DB_PASS="${{ needs.terraform.outputs.db_password }}"

          DATABASE_URL="postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=require"

          # Write JSON file correctly
          cat <<EOF > appsettings.json
          {
            "PORT": "9000",
            "WEBSITES_PORT": "9000",
            "NODE_ENV": "production",
            "DATABASE_URL": "${DATABASE_URL}",
            "PUBLIC_BACKEND_URL": "https://${{ needs.terraform.outputs.cms_url }}",
            "STORE_CORS": "*",
            "ADMIN_CORS": "*",
            "AUTH_CORS": "*",
            "DISABLE_MEDUSA_ADMIN": "false",
            "MEDUSA_WORKER_MODE": "server"
          }
          EOF

          echo "Generated appsettings.json:"
          cat appsettings.json

          # Apply app settings
          az webapp config appsettings set \
            --name "$APP" \
            --resource-group "$RG" \
            --settings @appsettings.json


      
      
      # - name: Configure App Service container + app settings
      #   run: |
      #     RG="${{ needs.terraform.outputs.resource_group_name }}"
      #     APP="${{ needs.terraform.outputs.app_service_name }}"
      #     IMAGE_NAME_ENV="$IMAGE"

      #     az webapp config container set \
      #       --name "$APP" \
      #       --resource-group "$RG" \
      #       --container-image-name "$IMAGE" \
      #       --container-registry-url "https://${{ needs.terraform.outputs.acr_login_server }}" \
      #       --container-registry-user "$ACR_USER" \
      #       --container-registry-password "$ACR_PASS"

      #     # Build DATABASE_URL: postgres://user:pass@host:port/dbname?sslmode=require
      #     DB_HOST="${{ needs.terraform.outputs.db_host }}"
      #     DB_PORT="${{ needs.terraform.outputs.db_port }}"
      #     DB_NAME="${{ needs.terraform.outputs.db_name }}"
      #     DB_USER="${{ needs.terraform.outputs.db_user }}"
      #     DB_PASS="${{ needs.terraform.outputs.db_password }}"

      #     DATABASE_URL="postgres://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}?sslmode=require"

      #     APP_SETTINGS=(
      #       "WEBSITES_PORT=9000"
      #       "DATABASE_URL=${DATABASE_URL}"
      #       "NODE_ENV=production"
      #       # Provide secrets via repo secrets:
      #       "JWT_SECRET=${{ secrets.JWT_SECRET }}"
      #       #"COOKIE_SECRET=${{ secrets.COOKIE_SECRET }}"
      #       # optional extras - add these secrets if you use redis or cors, otherwise remove
      #       "REDIS_URL=${{ secrets.REDIS_URL }}"
      #       "PUBLIC_BACKEND_URL=https://${{ needs.terraform.outputs.cms_url }}"
      #     )

      #     SETTINGS_JSON=""
      #     for s in "${APP_SETTINGS[@]}"; do
      #       SETTINGS_JSON="$SETTINGS_JSON $s"
      #     done

      #     az webapp config appsettings set --name "$APP" --resource-group "$RG" --settings $SETTINGS_JSON

      - name: Wait for Medusa to respond
        run: |
          APP_HOST="${{ needs.terraform.outputs.cms_url }}"
          echo "Waiting for https://${APP_HOST}/health to respond..."
          # wait until curl returns success
          for i in $(seq 1 30); do
            if curl -sS --fail "https://${APP_HOST}/health" >/dev/null 2>&1; then
              echo "App responded at https://${APP_HOST}/health && https://${APP_HOST}/app/login"
              exit 0
            fi
            echo "Attempt $i: no response yet..."
            sleep 10
          done
          echo "App did not respond in time."
          exit 1

      # - name: Delete temporary ACR
      #   if: always()
      #   run: |
      #     echo "Deleting temporary ACR..."
      #     ACR_NAME="${{ needs.terraform.outputs.acr_name }}"
      #     RG_NAME="${{ needs.terraform.outputs.resource_group_name }}"

      #     if [ -z "$ACR_NAME" ]; then
      #       echo "ERROR: ACR name is empty. Skipping delete."
      #       exit 0
      #     fi

      #     echo "ACR = $ACR_NAME"
      #     echo "RG  = $RG_NAME"

      #     az acr delete --name "$ACR_NAME" --resource-group "$RG_NAME" --yes
      #     echo "ACR deleted successfully"
